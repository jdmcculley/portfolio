#!/usr/bin/env node
/**
 * Forge Design System — Build Script
 *
 * Reads forge.tokens.json and generates:
 *   1. forge.generated.css   — CSS custom properties (per-theme)
 *   2. forge.generated.md    — Markdown reference for AI agents
 *
 * Usage:
 *   node design-system/build.mjs
 *
 * This is ADDITIVE — it does NOT touch globals.css or any existing file.
 * When you're ready to migrate, you can swap globals.css to @import this
 * generated CSS instead of hand-maintaining token values.
 */

import { readFileSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const tokens = JSON.parse(readFileSync(join(__dirname, 'forge.tokens.json'), 'utf-8'));

/* ═══════════════════════════════════════
   1. GENERATE CSS
   ═══════════════════════════════════════ */

function flattenTokens(obj, prefix = '') {
  const result = [];
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'object' && !Array.isArray(value)) {
      result.push(...flattenTokens(value, prefix));
    } else {
      result.push({ name: `--${key}`, value });
    }
  }
  return result;
}

function buildThemeBlock(selector, themeData) {
  const allTokens = [];
  for (const category of Object.values(themeData)) {
    if (typeof category === 'object') {
      allTokens.push(...flattenTokens(category));
    }
  }
  const vars = allTokens.map(t => `  ${t.name}: ${t.value};`).join('\n');
  return `${selector} {\n${vars}\n}`;
}

let css = `/* ════════════════════════════════════════════════
   AUTO-GENERATED by design-system/build.mjs
   Source: design-system/forge.tokens.json
   Do not edit — edit the JSON source instead.
   ════════════════════════════════════════════════ */\n\n`;

// Theme blocks
css += buildThemeBlock(':root,\n[data-theme="dark"]', tokens.themes.dark) + '\n\n';
css += buildThemeBlock('[data-theme="light"]', tokens.themes.light) + '\n\n';
css += buildThemeBlock('[data-theme="tech-dark"]', tokens.themes['tech-dark']) + '\n\n';

// Static tokens (not theme-dependent)
css += `/* ── Static Tokens ── */\n:root {\n`;
css += `  /* Layout */\n`;
for (const [key, value] of Object.entries(tokens.layout)) {
  css += `  --${key}: ${value};\n`;
}
css += `\n  /* Typography */\n`;
for (const [key, family] of Object.entries(tokens.typography.families)) {
  css += `  --font-${key}: ${family.stack};\n`;
}
css += `\n  /* Motion */\n`;
for (const [key, value] of Object.entries(tokens.motion.easing)) {
  css += `  --${key}: ${value};\n`;
}
css += `}\n\n`;

// Responsive overrides
css += `/* ── Responsive Overrides ── */\n`;
for (const [query, overrides] of Object.entries(tokens.responsive)) {
  let mediaQuery;
  if (query.startsWith('>=')) {
    mediaQuery = `(min-width: ${query.slice(2)})`;
  } else if (query.startsWith('<=')) {
    mediaQuery = `(max-width: ${query.slice(2)})`;
  } else {
    mediaQuery = query;
  }
  const vars = Object.entries(overrides).map(([k, v]) => `    --${k}: ${v};`).join('\n');
  css += `@media ${mediaQuery} {\n  :root {\n${vars}\n  }\n}\n\n`;
}

writeFileSync(join(__dirname, 'forge.generated.css'), css, 'utf-8');
console.log('✓ Generated design-system/forge.generated.css');

/* ═══════════════════════════════════════
   2. GENERATE MARKDOWN (Agent Reference)
   ═══════════════════════════════════════ */

let md = `# Forge Design System — Token Reference\n\n`;
md += `> Auto-generated from \`design-system/forge.tokens.json\`  \n`;
md += `> Version: ${tokens.version}\n\n`;

// Colors (dark theme as primary reference)
md += `## Color Tokens (Dark Theme — Default)\n\n`;
md += `| Token | Value | Category |\n|---|---|---|\n`;
const dark = tokens.themes.dark;
for (const [category, group] of Object.entries(dark)) {
  if (typeof group === 'object') {
    for (const [name, value] of Object.entries(group)) {
      md += `| \`--${name}\` | \`${value}\` | ${category} |\n`;
    }
  }
}

// Typography
md += `\n## Typography\n\n`;
md += `| Family | CSS Variable | Stack | Weights |\n|---|---|---|---|\n`;
for (const [key, fam] of Object.entries(tokens.typography.families)) {
  md += `| ${key} | \`--font-${key}\` | ${fam.stack} | ${fam.weights.join(', ')} |\n`;
}
md += `\n### Type Scale\n\n`;
md += `| Name | Size | Weight | Family | Notes |\n|---|---|---|---|---|\n`;
for (const step of tokens.typography.scale) {
  const notes = [step.tracking && `tracking: ${step.tracking}`, step.transform, step.lineHeight && `line-height: ${step.lineHeight}`].filter(Boolean).join(', ') || '—';
  md += `| ${step.name} | ${step.size} | ${step.weight} | ${step.family} | ${notes} |\n`;
}

// Spacing
md += `\n## Spacing\n\nScale: ${tokens.spacing.scale.join(', ')} (${tokens.spacing.unit})\n\n`;

// Radii
md += `## Border Radius\n\n`;
md += `| Token | Value |\n|---|---|\n`;
for (const [name, value] of Object.entries(tokens.radii)) {
  md += `| ${name} | ${value} |\n`;
}

// Layout
md += `\n## Layout\n\n`;
md += `| Token | Value |\n|---|---|\n`;
for (const [name, value] of Object.entries(tokens.layout)) {
  md += `| \`--${name}\` | ${value} |\n`;
}

// Breakpoints
md += `\n## Breakpoints\n\n`;
md += `| Name | Width |\n|---|---|\n`;
for (const [name, value] of Object.entries(tokens.breakpoints)) {
  md += `| ${name} | ${value} |\n`;
}

// Motion
md += `\n## Motion\n\n`;
md += `### Easing\n\n`;
for (const [name, value] of Object.entries(tokens.motion.easing)) {
  md += `- \`--${name}\`: \`${value}\`\n`;
}
md += `\n### Keyframe Animations\n\n`;
md += `| Name | Duration | Easing | Loop | Description |\n|---|---|---|---|---|\n`;
for (const [name, anim] of Object.entries(tokens.motion.keyframes)) {
  md += `| ${name} | ${anim.duration || '—'} | ${anim.easing || '—'} | ${anim.loop ? 'infinite' : 'once'} | ${anim.description} |\n`;
}

// Components
md += `\n## Components\n\n`;
for (const [name, comp] of Object.entries(tokens.components)) {
  md += `### ${name}\n\n`;
  md += `Import: \`${comp.import}\`\n\n`;
  if (comp.description) md += `${comp.description}\n\n`;
  if (comp.variants) md += `Variants: ${comp.variants.map(v => `\`${v}\``).join(', ')}\n\n`;
  md += `| Prop | Type | Required | Default |\n|---|---|---|---|\n`;
  for (const [prop, info] of Object.entries(comp.props)) {
    md += `| ${prop} | ${info.type} | ${info.required ? 'yes' : 'no'} | ${info.default ?? '—'} |\n`;
  }
  md += `\n`;
}

// Patterns
md += `## Patterns\n\n`;
for (const [name, value] of Object.entries(tokens.patterns)) {
  md += `### ${name}\n\`\`\`\n${value}\n\`\`\`\n\n`;
}

writeFileSync(join(__dirname, 'forge.generated.md'), md, 'utf-8');
console.log('✓ Generated design-system/forge.generated.md');

console.log('\nDone. No existing files were modified.');
